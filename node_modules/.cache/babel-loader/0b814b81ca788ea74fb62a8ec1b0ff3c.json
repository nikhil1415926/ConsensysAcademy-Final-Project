{"ast":null,"code":"'use strict';\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar address_1 = require(\"./address\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar hash_1 = require(\"./hash\");\n\nvar keccak256_1 = require(\"./keccak256\");\n\nvar properties_1 = require(\"./properties\");\n\nvar errors = __importStar(require(\"./errors\"));\n\nvar KeyPair =\n/** @class */\nfunction () {\n  function KeyPair(privateKey) {\n    var keyPair = curve.keyFromPrivate(bytes_1.arrayify(privateKey));\n    properties_1.defineReadOnly(this, 'privateKey', bytes_1.hexlify(keyPair.priv.toArray('be', 32)));\n    properties_1.defineReadOnly(this, 'publicKey', '0x' + keyPair.getPublic(false, 'hex'));\n    properties_1.defineReadOnly(this, 'compressedPublicKey', '0x' + keyPair.getPublic(true, 'hex'));\n    properties_1.defineReadOnly(this, 'publicKeyBytes', keyPair.getPublic().encode(null, true));\n  }\n\n  KeyPair.prototype.sign = function (digest) {\n    var keyPair = curve.keyFromPrivate(bytes_1.arrayify(this.privateKey));\n    var signature = keyPair.sign(bytes_1.arrayify(digest), {\n      canonical: true\n    });\n    return {\n      recoveryParam: signature.recoveryParam,\n      r: bytes_1.hexZeroPad('0x' + signature.r.toString(16), 32),\n      s: bytes_1.hexZeroPad('0x' + signature.s.toString(16), 32),\n      v: 27 + signature.recoveryParam\n    };\n  };\n\n  return KeyPair;\n}();\n\nexports.KeyPair = KeyPair;\n\nfunction recoverPublicKey(digest, signature) {\n  var sig = {\n    r: bytes_1.arrayify(signature.r),\n    s: bytes_1.arrayify(signature.s)\n  };\n  return '0x' + curve.recoverPubKey(bytes_1.arrayify(digest), sig, signature.recoveryParam).encode('hex', false);\n}\n\nexports.recoverPublicKey = recoverPublicKey;\n\nfunction computePublicKey(key, compressed) {\n  var bytes = bytes_1.arrayify(key);\n\n  if (bytes.length === 32) {\n    var keyPair = new KeyPair(bytes);\n\n    if (compressed) {\n      return keyPair.compressedPublicKey;\n    }\n\n    return keyPair.publicKey;\n  } else if (bytes.length === 33) {\n    if (compressed) {\n      return bytes_1.hexlify(bytes);\n    }\n\n    return '0x' + curve.keyFromPublic(bytes).getPublic(false, 'hex');\n  } else if (bytes.length === 65) {\n    if (!compressed) {\n      return bytes_1.hexlify(bytes);\n    }\n\n    return '0x' + curve.keyFromPublic(bytes).getPublic(true, 'hex');\n  }\n\n  errors.throwError('invalid public or private key', errors.INVALID_ARGUMENT, {\n    arg: 'key',\n    value: '[REDACTED]'\n  });\n  return null;\n}\n\nexports.computePublicKey = computePublicKey;\n\nfunction recoverAddress(digest, signature) {\n  return computeAddress(recoverPublicKey(digest, signature));\n}\n\nexports.recoverAddress = recoverAddress;\n\nfunction computeAddress(key) {\n  // Strip off the leading \"0x04\"\n  var publicKey = '0x' + computePublicKey(key).slice(4);\n  return address_1.getAddress('0x' + keccak256_1.keccak256(publicKey).substring(26));\n}\n\nexports.computeAddress = computeAddress;\n\nfunction verifyMessage(message, signature) {\n  var sig = bytes_1.splitSignature(signature);\n  var digest = hash_1.hashMessage(message);\n  return recoverAddress(digest, {\n    r: sig.r,\n    s: sig.s,\n    recoveryParam: sig.recoveryParam\n  });\n}\n\nexports.verifyMessage = verifyMessage; // !!!!!! IMPORTANT !!!!!!!!\n//\n// This import MUST be at the bottom, otehrwise browserify executes several imports\n// BEFORE they are exported, resulting in undefined\n\nvar elliptic_1 = require(\"elliptic\");\n\nvar curve = new elliptic_1.ec('secp256k1');\nexports.N = '0x' + curve.n.toString(16);","map":null,"metadata":{},"sourceType":"script"}