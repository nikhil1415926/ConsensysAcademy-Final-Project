{"ast":null,"code":"var debug = require(\"debug\")(\"contract:utils\"); // eslint-disable-line no-unused-vars\n\n\nvar Web3 = require(\"web3\");\n\nvar ethers = require(\"ethers\");\n\nvar abi = require(\"web3-eth-abi\");\n\nvar reformat = require(\"./reformat\");\n\nvar web3 = new Web3();\nvar Utils = {\n  is_object: function is_object(val) {\n    return typeof val === \"object\" && !Array.isArray(val);\n  },\n  is_big_number: function is_big_number(val) {\n    if (typeof val !== \"object\") return false;\n    return web3.utils.isBN(val) || web3.utils.isBigNumber(val);\n  },\n  is_tx_params: function is_tx_params(val) {\n    if (!Utils.is_object(val)) return false;\n    if (Utils.is_big_number(val)) return false;\n    var allowed_fields = {\n      from: true,\n      to: true,\n      gas: true,\n      gasPrice: true,\n      value: true,\n      data: true,\n      nonce: true\n    };\n\n    var _arr = Object.keys(val);\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      field_name = _arr[_i];\n      if (allowed_fields[field_name]) return true;\n    }\n\n    return false;\n  },\n  decodeLogs: function decodeLogs(_logs, isSingle) {\n    var constructor = this;\n    var logs = Utils.toTruffleLog(_logs, isSingle);\n    return logs.map(function (log) {\n      var logABI = constructor.events[log.topics[0]];\n\n      if (logABI == null) {\n        return null;\n      }\n\n      var copy = Utils.merge({}, log);\n      copy.event = logABI.name;\n      copy.topics = logABI.anonymous ? copy.topics : copy.topics.slice(1);\n\n      if (copy.data === \"0x\") {\n        copy.data = \"\";\n      }\n\n      var logArgs = abi.decodeLog(logABI.inputs, copy.data, copy.topics);\n      copy.args = reformat.numbers.call(constructor, logArgs, logABI.inputs);\n      delete copy.data;\n      delete copy.topics;\n      return copy;\n    }).filter(function (log) {\n      return log != null;\n    });\n  },\n  toTruffleLog: function toTruffleLog(events, isSingle) {\n    // Transform singletons (from event listeners) to the kind of\n    // object we find on the receipt\n    if (isSingle && typeof isSingle === \"boolean\") {\n      var temp = [];\n      temp.push(events);\n      return temp.map(function (log) {\n        log.data = log.raw.data;\n        log.topics = log.raw.topics;\n        return log;\n      });\n    } // Or reformat items in the existing array\n\n\n    events.forEach(function (event) {\n      if (event.raw) {\n        event.data = event.raw.data;\n        event.topics = event.raw.topics;\n      }\n    });\n    return events;\n  },\n  merge: function merge() {\n    var merged = {};\n    var args = Array.prototype.slice.call(arguments);\n\n    for (var i = 0; i < args.length; i++) {\n      var object = args[i];\n      var keys = Object.keys(object);\n\n      for (var j = 0; j < keys.length; j++) {\n        var key = keys[j];\n        var value = object[key];\n        merged[key] = value;\n      }\n    }\n\n    return merged;\n  },\n  parallel: function parallel(arr, callback) {\n    callback = callback || function () {};\n\n    if (!arr.length) {\n      return callback(null, []);\n    }\n\n    var index = 0;\n    var results = new Array(arr.length);\n    arr.forEach(function (fn, position) {\n      fn(function (err, result) {\n        if (err) {\n          callback(err);\n\n          callback = function callback() {};\n        } else {\n          index++;\n          results[position] = result;\n\n          if (index >= arr.length) {\n            callback(null, results);\n          }\n        }\n      });\n    });\n  },\n  linkBytecode: function linkBytecode(bytecode, links) {\n    Object.keys(links).forEach(function (library_name) {\n      var library_address = links[library_name];\n      var regex = new RegExp(\"__\" + library_name + \"_+\", \"g\");\n      bytecode = bytecode.replace(regex, library_address.replace(\"0x\", \"\"));\n    });\n    return bytecode;\n  },\n  // Extracts optional tx params from a list of fn arguments\n  getTxParams: function getTxParams(methodABI, args) {\n    var constructor = this;\n    var expected_arg_count = methodABI ? methodABI.inputs.length : 0;\n    tx_params = {};\n    var last_arg = args[args.length - 1];\n\n    if (args.length === expected_arg_count + 1 && Utils.is_tx_params(last_arg)) {\n      tx_params = args.pop();\n    }\n\n    return Utils.merge(constructor.class_defaults, tx_params);\n  },\n  // Verifies that a contracts libraries have been linked correctly.\n  // Throws on error\n  checkLibraries: function checkLibraries() {\n    var constructor = this;\n    var regex = /__[^_]+_+/g;\n    var unlinked_libraries = constructor.binary.match(regex);\n\n    if (unlinked_libraries !== null) {\n      unlinked_libraries = unlinked_libraries.map(function (name) {\n        // Remove underscores\n        return name.replace(/_/g, \"\");\n      }).sort().filter(function (name, index, arr) {\n        // Remove duplicates\n        if (index + 1 >= arr.length) {\n          return true;\n        }\n\n        return name !== arr[index + 1];\n      }).join(\", \");\n      var error = constructor.contractName + \" contains unresolved libraries. You must deploy and link\" + \" the following libraries before you can deploy a new version of \" + constructor.contractName + \": \" + unlinked_libraries;\n      throw new Error(error);\n    }\n  },\n  convertToEthersBN: function convertToEthersBN(original) {\n    var converted = [];\n    original.forEach(function (item) {\n      // Recurse for arrays\n      if (Array.isArray(item)) {\n        converted.push(Utils.convertToEthersBN(item)); // Convert Web3 BN / BigNumber\n      } else if (Utils.is_big_number(item)) {\n        var ethersBN = ethers.utils.bigNumberify(item.toString());\n        converted.push(ethersBN);\n      } else {\n        converted.push(item);\n      }\n    });\n    return converted;\n  }\n};\nmodule.exports = Utils;","map":null,"metadata":{},"sourceType":"script"}