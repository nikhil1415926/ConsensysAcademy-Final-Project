{"ast":null,"code":"'use strict';\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar interface_1 = require(\"./interface\");\n\nvar abi_coder_1 = require(\"../utils/abi-coder\");\n\nvar address_1 = require(\"../utils/address\");\n\nvar bignumber_1 = require(\"../utils/bignumber\");\n\nvar bytes_1 = require(\"../utils/bytes\");\n\nvar properties_1 = require(\"../utils/properties\");\n\nvar web_1 = require(\"../utils/web\");\n\nvar types_1 = require(\"../utils/types\");\n\nvar errors = __importStar(require(\"../utils/errors\"));\n\nvar allowedTransactionKeys = {\n  data: true,\n  from: true,\n  gasLimit: true,\n  gasPrice: true,\n  nonce: true,\n  to: true,\n  value: true\n}; // Recursively replaces ENS names with promises to resolve the name and\n// stalls until all promises have returned\n// @TODO: Expand this to resolve any promises too\n\nfunction resolveAddresses(provider, value, paramType) {\n  if (Array.isArray(paramType)) {\n    var promises = [];\n    paramType.forEach(function (paramType, index) {\n      var v = null;\n\n      if (Array.isArray(value)) {\n        v = value[index];\n      } else {\n        v = value[paramType.name];\n      }\n\n      promises.push(resolveAddresses(provider, v, paramType));\n    });\n    return Promise.all(promises);\n  }\n\n  if (paramType.type === 'address') {\n    return provider.resolveName(value);\n  }\n\n  if (paramType.components) {\n    return resolveAddresses(provider, value, paramType.components);\n  }\n\n  return Promise.resolve(value);\n}\n\nfunction runMethod(contract, functionName, estimateOnly) {\n  var method = contract.interface.functions[functionName];\n  return function () {\n    var params = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      params[_i] = arguments[_i];\n    }\n\n    var tx = {}; // If 1 extra parameter was passed in, it contains overrides\n\n    if (params.length === method.inputs.length + 1 && typeof params[params.length - 1] === 'object') {\n      tx = properties_1.shallowCopy(params.pop()); // Check for unexpected keys (e.g. using \"gas\" instead of \"gasLimit\")\n\n      for (var key in tx) {\n        if (!allowedTransactionKeys[key]) {\n          throw new Error('unknown transaction override ' + key);\n        }\n      }\n    }\n\n    if (params.length != method.inputs.length) {\n      throw new Error('incorrect number of arguments');\n    } // Check overrides make sense\n\n\n    ['data', 'to'].forEach(function (key) {\n      if (tx[key] != null) {\n        errors.throwError('cannot override ' + key, errors.UNSUPPORTED_OPERATION, {\n          operation: key\n        });\n      }\n    }); // Send to the contract address\n\n    tx.to = contract.addressPromise;\n    return resolveAddresses(contract.provider, params, method.inputs).then(function (params) {\n      tx.data = method.encode(params);\n\n      if (method.type === 'call') {\n        // Call (constant functions) always cost 0 ether\n        if (estimateOnly) {\n          return Promise.resolve(bignumber_1.ConstantZero);\n        }\n\n        if (!contract.provider) {\n          errors.throwError('call (constant functions) require a provider or a signer with a provider', errors.UNSUPPORTED_OPERATION, {\n            operation: 'call'\n          });\n        } // Check overrides make sense\n\n\n        ['gasLimit', 'gasPrice', 'value'].forEach(function (key) {\n          if (tx[key] != null) {\n            throw new Error('call cannot override ' + key);\n          }\n        });\n\n        if (tx.from == null && contract.signer) {\n          tx.from = contract.signer.getAddress();\n        }\n\n        return contract.provider.call(tx).then(function (value) {\n          if (bytes_1.hexDataLength(value) % 32 === 4 && bytes_1.hexDataSlice(value, 0, 4) === '0x08c379a0') {\n            var reason = abi_coder_1.defaultAbiCoder.decode(['string'], bytes_1.hexDataSlice(value, 4));\n            errors.throwError('call revert exception', errors.CALL_EXCEPTION, {\n              address: contract.address,\n              args: params,\n              method: method.signature,\n              errorSignature: 'Error(string)',\n              errorArgs: [reason],\n              reason: reason,\n              transaction: tx\n            });\n          }\n\n          try {\n            var result = method.decode(value);\n\n            if (method.outputs.length === 1) {\n              result = result[0];\n            }\n\n            return result;\n          } catch (error) {\n            if (value === '0x' && method.outputs.length > 0) {\n              errors.throwError('call exception', errors.CALL_EXCEPTION, {\n                address: contract.address,\n                method: method.signature,\n                args: params\n              });\n            }\n\n            throw error;\n          }\n        });\n      } else if (method.type === 'transaction') {\n        // Only computing the transaction estimate\n        if (estimateOnly) {\n          if (!contract.provider) {\n            errors.throwError('estimate gas require a provider or a signer with a provider', errors.UNSUPPORTED_OPERATION, {\n              operation: 'estimateGas'\n            });\n          }\n\n          if (tx.from == null && contract.signer) {\n            tx.from = contract.signer.getAddress();\n          }\n\n          return contract.provider.estimateGas(tx);\n        }\n\n        if (!contract.signer) {\n          errors.throwError('sending a transaction require a signer', errors.UNSUPPORTED_OPERATION, {\n            operation: 'sendTransaction'\n          });\n        } // Make sure they aren't overriding something they shouldn't\n\n\n        if (tx.from != null) {\n          errors.throwError('cannot override from in a transaction', errors.UNSUPPORTED_OPERATION, {\n            operation: 'sendTransaction'\n          });\n        }\n\n        return contract.signer.sendTransaction(tx);\n      }\n\n      throw new Error('invalid type - ' + method.type);\n      return null;\n    });\n  };\n}\n\nfunction getEventTag(filter) {\n  return (filter.address || '') + (filter.topics ? filter.topics.join(':') : '');\n}\n\nvar Contract =\n/** @class */\nfunction () {\n  // https://github.com/Microsoft/TypeScript/issues/5453\n  // Once this issue is resolved (there are open PR) we can do this nicer\n  // by making addressOrName default to null for 2 operand calls. :)\n  function Contract(addressOrName, contractInterface, signerOrProvider) {\n    var _this = this;\n\n    errors.checkNew(this, Contract); // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n    //address = getAddress(address);\n\n    if (contractInterface instanceof interface_1.Interface) {\n      properties_1.defineReadOnly(this, 'interface', contractInterface);\n    } else {\n      properties_1.defineReadOnly(this, 'interface', new interface_1.Interface(contractInterface));\n    }\n\n    if (signerOrProvider instanceof types_1.Signer) {\n      properties_1.defineReadOnly(this, 'provider', signerOrProvider.provider);\n      properties_1.defineReadOnly(this, 'signer', signerOrProvider);\n    } else if (signerOrProvider instanceof types_1.MinimalProvider) {\n      properties_1.defineReadOnly(this, 'provider', signerOrProvider);\n      properties_1.defineReadOnly(this, 'signer', null);\n    } else {\n      errors.throwError('invalid signer or provider', errors.INVALID_ARGUMENT, {\n        arg: 'signerOrProvider',\n        value: signerOrProvider\n      });\n    }\n\n    properties_1.defineReadOnly(this, 'estimate', {});\n    properties_1.defineReadOnly(this, 'functions', {});\n    properties_1.defineReadOnly(this, 'filters', {});\n    Object.keys(this.interface.events).forEach(function (eventName) {\n      var event = _this.interface.events[eventName];\n      properties_1.defineReadOnly(_this.filters, eventName, function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return {\n          address: _this.address,\n          topics: event.encodeTopics(args)\n        };\n      });\n    }); // Not connected to an on-chain instance, so do not connect functions and events\n\n    if (!addressOrName) {\n      properties_1.defineReadOnly(this, 'address', null);\n      properties_1.defineReadOnly(this, 'addressPromise', Promise.resolve(null));\n      return;\n    }\n\n    this._events = [];\n    properties_1.defineReadOnly(this, 'address', addressOrName);\n\n    if (this.provider) {\n      properties_1.defineReadOnly(this, 'addressPromise', this.provider.resolveName(addressOrName).then(function (address) {\n        if (address == null) {\n          throw new Error('name not found');\n        }\n\n        return address;\n      }).catch(function (error) {\n        console.log('ERROR: Cannot find Contract - ' + addressOrName);\n        throw error;\n      }));\n    } else {\n      try {\n        properties_1.defineReadOnly(this, 'addressPromise', Promise.resolve(address_1.getAddress(addressOrName)));\n      } catch (error) {\n        errors.throwError('provider is required to use non-address contract address', errors.INVALID_ARGUMENT, {\n          argument: 'addressOrName',\n          value: addressOrName\n        });\n      }\n    }\n\n    Object.keys(this.interface.functions).forEach(function (name) {\n      var run = runMethod(_this, name, false);\n\n      if (_this[name] == null) {\n        properties_1.defineReadOnly(_this, name, run);\n      } else {\n        console.log('WARNING: Multiple definitions for ' + name);\n      }\n\n      if (_this.functions[name] == null) {\n        properties_1.defineReadOnly(_this.functions, name, run);\n        properties_1.defineReadOnly(_this.estimate, name, runMethod(_this, name, true));\n      }\n    });\n  } // @TODO: Allow timeout?\n\n\n  Contract.prototype.deployed = function () {\n    var _this = this; // If we were just deployed, we know the transaction we should occur in\n\n\n    if (this.deployTransaction) {\n      return this.deployTransaction.wait().then(function () {\n        return _this;\n      });\n    } // Otherwise, poll for our code to be deployed\n\n\n    return web_1.poll(function () {\n      return _this.provider.getCode(_this.address).then(function (code) {\n        if (code === '0x') {\n          return undefined;\n        }\n\n        return _this;\n      });\n    }, {\n      onceBlock: this.provider\n    });\n  }; // @TODO:\n  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n  // @TODO:\n  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n\n\n  Contract.prototype.fallback = function (overrides) {\n    if (!this.signer) {\n      errors.throwError('sending a transaction require a signer', errors.UNSUPPORTED_OPERATION, {\n        operation: 'sendTransaction(fallback)'\n      });\n    }\n\n    var tx = properties_1.shallowCopy(overrides || {});\n    ['from', 'to'].forEach(function (key) {\n      if (tx[key] == null) {\n        return;\n      }\n\n      errors.throwError('cannot override ' + key, errors.UNSUPPORTED_OPERATION, {\n        operation: key\n      });\n    });\n    tx.to = this.addressPromise;\n    return this.signer.sendTransaction(tx);\n  }; // Reconnect to a different signer or provider\n\n\n  Contract.prototype.connect = function (signerOrProvider) {\n    return new Contract(this.address, this.interface, signerOrProvider);\n  }; // Re-attach to a different on=chain instance of this contract\n\n\n  Contract.prototype.attach = function (addressOrName) {\n    return new Contract(addressOrName, this.interface, this.signer || this.provider);\n  }; // Deploy the contract with the bytecode, resolving to the deployed address.\n  // Use contract.deployTransaction.wait() to wait until the contract has\n  // been mined.\n\n\n  Contract.prototype.deploy = function (bytecode) {\n    var _this = this;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    if (this.signer == null) {\n      throw new Error('missing signer'); // @TODO: errors.throwError\n    } // A lot of common tools do not prefix bytecode with a 0x\n\n\n    if (typeof bytecode === 'string' && bytecode.match(/^[0-9a-f]*$/i) && bytecode.length % 2 == 0) {\n      bytecode = '0x' + bytecode;\n    }\n\n    if (!bytes_1.isHexString(bytecode)) {\n      errors.throwError('bytecode must be a valid hex string', errors.INVALID_ARGUMENT, {\n        arg: 'bytecode',\n        value: bytecode\n      });\n    }\n\n    if (bytecode.length % 2 !== 0) {\n      errors.throwError('bytecode must be valid data (even length)', errors.INVALID_ARGUMENT, {\n        arg: 'bytecode',\n        value: bytecode\n      });\n    }\n\n    var tx = {};\n\n    if (args.length === this.interface.deployFunction.inputs.length + 1) {\n      tx = properties_1.shallowCopy(args.pop());\n\n      for (var key in tx) {\n        if (!allowedTransactionKeys[key]) {\n          throw new Error('unknown transaction override ' + key);\n        }\n      }\n    }\n\n    ['data', 'from', 'to'].forEach(function (key) {\n      if (tx[key] == null) {\n        return;\n      }\n\n      errors.throwError('cannot override ' + key, errors.UNSUPPORTED_OPERATION, {\n        operation: key\n      });\n    });\n    tx.data = this.interface.deployFunction.encode(bytecode, args);\n    errors.checkArgumentCount(args.length, this.interface.deployFunction.inputs.length, 'in Contract constructor'); // @TODO: overrides of args.length = this.interface.deployFunction.inputs.length + 1\n\n    return this.signer.sendTransaction(tx).then(function (tx) {\n      var contract = new Contract(address_1.getContractAddress(tx), _this.interface, _this.signer || _this.provider);\n      properties_1.defineReadOnly(contract, 'deployTransaction', tx);\n      return contract;\n    });\n  };\n\n  Contract.prototype._getEventFilter = function (eventName) {\n    var _this = this;\n\n    if (typeof eventName === 'string') {\n      // Listen for any event\n      if (eventName === '*') {\n        return {\n          decode: function decode(log) {\n            return [_this.interface.parseLog(log)];\n          },\n          eventTag: '*',\n          filter: {\n            address: this.address\n          }\n        };\n      } // Normalize the eventName\n\n\n      if (eventName.indexOf('(') !== -1) {\n        eventName = abi_coder_1.formatSignature(abi_coder_1.parseSignature('event ' + eventName));\n      }\n\n      var event_1 = this.interface.events[eventName];\n\n      if (!event_1) {\n        errors.throwError('unknown event - ' + eventName, errors.INVALID_ARGUMENT, {\n          argumnet: 'eventName',\n          value: eventName\n        });\n      }\n\n      var filter_1 = {\n        address: this.address,\n        topics: [event_1.topic]\n      };\n      return {\n        decode: function decode(log) {\n          return event_1.decode(log.data, log.topics);\n        },\n        event: event_1,\n        eventTag: getEventTag(filter_1),\n        filter: filter_1\n      };\n    }\n\n    var filter = {\n      address: this.address\n    }; // Find the matching event in the ABI; if none, we still allow filtering\n    // since it may be a filter for an otherwise unknown event\n\n    var event = null;\n\n    if (eventName.topics && eventName.topics[0]) {\n      filter.topics = eventName.topics;\n\n      for (var name in this.interface.events) {\n        if (name.indexOf('(') === -1) {\n          continue;\n        }\n\n        var e = this.interface.events[name];\n\n        if (e.topic === eventName.topics[0].toLowerCase()) {\n          event = e;\n          break;\n        }\n      }\n    }\n\n    return {\n      decode: function decode(log) {\n        if (event) {\n          return event.decode(log.data, log.topics);\n        }\n\n        return [log];\n      },\n      event: event,\n      eventTag: getEventTag(filter),\n      filter: filter\n    };\n  };\n\n  Contract.prototype._addEventListener = function (eventFilter, listener, once) {\n    var _this = this;\n\n    if (!this.provider) {\n      errors.throwError('events require a provider or a signer with a provider', errors.UNSUPPORTED_OPERATION, {\n        operation: 'once'\n      });\n    }\n\n    var wrappedListener = function wrappedListener(log) {\n      var decoded = Array.prototype.slice.call(eventFilter.decode(log));\n      var event = properties_1.jsonCopy(log);\n      event.args = decoded;\n      event.decode = eventFilter.event.decode;\n      event.event = eventFilter.event.name;\n      event.eventSignature = eventFilter.event.signature;\n\n      event.removeListener = function () {\n        _this.removeListener(eventFilter.filter, listener);\n      };\n\n      event.getBlock = function () {\n        return _this.provider.getBlock(log.blockHash);\n      };\n\n      event.getTransaction = function () {\n        return _this.provider.getTransactionReceipt(log.transactionHash);\n      };\n\n      event.getTransactionReceipt = function () {\n        return _this.provider.getTransactionReceipt(log.transactionHash);\n      };\n\n      decoded.push(event);\n\n      _this.emit.apply(_this, [eventFilter.filter].concat(decoded));\n    };\n\n    this.provider.on(eventFilter.filter, wrappedListener);\n\n    this._events.push({\n      eventFilter: eventFilter,\n      listener: listener,\n      wrappedListener: wrappedListener,\n      once: once\n    });\n  };\n\n  Contract.prototype.on = function (event, listener) {\n    this._addEventListener(this._getEventFilter(event), listener, false);\n\n    return this;\n  };\n\n  Contract.prototype.once = function (event, listener) {\n    this._addEventListener(this._getEventFilter(event), listener, true);\n\n    return this;\n  };\n\n  Contract.prototype.addEventLisener = function (eventName, listener) {\n    return this.on(eventName, listener);\n  };\n\n  Contract.prototype.emit = function (eventName) {\n    var _this = this;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    if (!this.provider) {\n      return false;\n    }\n\n    var result = false;\n\n    var eventFilter = this._getEventFilter(eventName);\n\n    this._events = this._events.filter(function (event) {\n      if (event.eventFilter.eventTag !== eventFilter.eventTag) {\n        return true;\n      }\n\n      setTimeout(function () {\n        event.listener.apply(_this, args);\n      }, 0);\n      result = true;\n      return !event.once;\n    });\n    return result;\n  };\n\n  Contract.prototype.listenerCount = function (eventName) {\n    if (!this.provider) {\n      return 0;\n    }\n\n    var eventFilter = this._getEventFilter(eventName);\n\n    return this._events.filter(function (event) {\n      return event.eventFilter.eventTag === eventFilter.eventTag;\n    }).length;\n  };\n\n  Contract.prototype.listeners = function (eventName) {\n    if (!this.provider) {\n      return [];\n    }\n\n    var eventFilter = this._getEventFilter(eventName);\n\n    return this._events.filter(function (event) {\n      return event.eventFilter.eventTag === eventFilter.eventTag;\n    }).map(function (event) {\n      return event.listener;\n    });\n  };\n\n  Contract.prototype.removeAllListeners = function (eventName) {\n    if (!this.provider) {\n      return this;\n    }\n\n    var eventFilter = this._getEventFilter(eventName);\n\n    this._events = this._events.filter(function (event) {\n      return event.eventFilter.eventTag !== eventFilter.eventTag;\n    });\n    return this;\n  };\n\n  Contract.prototype.removeListener = function (eventName, listener) {\n    var _this = this;\n\n    if (!this.provider) {\n      return this;\n    }\n\n    var found = false;\n\n    var eventFilter = this._getEventFilter(eventName);\n\n    this._events = this._events.filter(function (event) {\n      // Make sure this event and listener match\n      if (event.eventFilter.eventTag !== eventFilter.eventTag) {\n        return true;\n      }\n\n      if (event.listener !== listener) {\n        return true;\n      }\n\n      _this.provider.removeListener(event.eventFilter.filter, event.wrappedListener); // Already found a matching event in a previous loop\n\n\n      if (found) {\n        return true;\n      } // REmove this event (returning false filters us out)\n\n\n      found = true;\n      return false;\n    });\n    return this;\n  };\n\n  return Contract;\n}();\n\nexports.Contract = Contract;","map":null,"metadata":{},"sourceType":"script"}