{"ast":null,"code":"var Web3PromiEvent = require(\"web3-core-promievent\");\n\nvar BlockchainUtils = require(\"truffle-blockchain-utils\");\n\nvar Web3 = require(\"web3\");\n\nvar utils = require(\"../utils\");\n\nvar execute = require(\"../execute\");\n\nvar bootstrap = require(\"./bootstrap\");\n\nmodule.exports = function (Contract) {\n  return {\n    setProvider: function setProvider(provider) {\n      if (!provider) {\n        throw new Error(\"Invalid provider passed to setProvider(); provider is \" + provider);\n      }\n\n      this.web3.setProvider(provider);\n      this.currentProvider = provider;\n    },\n    new: function _new() {\n      var constructor = this;\n      var promiEvent = new Web3PromiEvent();\n\n      if (!constructor.currentProvider) {\n        var err = constructor.contractName + \" error: Please call setProvider() first before calling new().\";\n        throw new Error(err);\n      }\n\n      if (!constructor.bytecode || constructor.bytecode === \"0x\") {\n        var err = \"\".concat(constructor.contractName, \" error: contract binary not set. Can't deploy new instance.\\n\") + \"This contract may be abstract, not implement an abstract parent's methods completely\\n\" + \"or not invoke an inherited contract's constructor correctly\\n\";\n        throw new Error(err);\n      }\n\n      var args = Array.prototype.slice.call(arguments); // Promievent and flag that allows instance to resolve (rather than just receipt)\n\n      var context = {\n        contract: constructor,\n        promiEvent: promiEvent,\n        onlyEmitReceipt: true\n      };\n      constructor.detectNetwork().then(function (network) {\n        utils.checkLibraries.apply(constructor);\n        return execute.deploy.call(constructor, args, context, network.blockLimit);\n      }).catch(promiEvent.reject);\n      return promiEvent.eventEmitter;\n    },\n    at: function at(address) {\n      var constructor = this;\n      return new Promise(function (accept, reject) {\n        if (address == null || typeof address !== \"string\" || address.length !== 42) {\n          var err = \"Invalid address passed to \" + constructor.contractName + \".at(): \" + address;\n          reject(new Error(err));\n        }\n\n        return constructor.detectNetwork().then(function () {\n          var instance = new constructor(address);\n          return constructor.web3.eth.getCode(address).then(function (code) {\n            if (!code || code.replace(\"0x\", \"\").replace(/0/g, \"\") === \"\") {\n              var err = \"Cannot create instance of \" + constructor.contractName + \"; no code at address \" + address;\n              reject(new Error(err));\n            }\n\n            accept(instance);\n          });\n        });\n      });\n    },\n    deployed: function deployed() {\n      var constructor = this;\n      return constructor.detectNetwork().then(function () {\n        // We don't have a network config for the one we found\n        if (constructor._json.networks[constructor.network_id] == null) {\n          var error = constructor.contractName + \" has not been deployed to detected network\" + \" (network/artifact mismatch)\";\n          throw new Error(error);\n        } // If we found the network but it's not deployed\n\n\n        if (!constructor.isDeployed()) {\n          var error = constructor.contractName + \" has not been deployed to detected network (\" + constructor.network_id + \")\";\n          throw new Error(error);\n        }\n\n        return new constructor(constructor.address);\n      });\n    },\n    defaults: function defaults(class_defaults) {\n      if (this.class_defaults == null) {\n        this.class_defaults = {};\n      }\n\n      if (class_defaults == null) {\n        class_defaults = {};\n      }\n\n      var constructor = this;\n      Object.keys(class_defaults).forEach(function (key) {\n        var value = class_defaults[key];\n        constructor.class_defaults[key] = value;\n      });\n      return this.class_defaults;\n    },\n    hasNetwork: function hasNetwork(network_id) {\n      return this._json.networks[network_id + \"\"] != null;\n    },\n    isDeployed: function isDeployed() {\n      if (this.network_id == null) {\n        return false;\n      }\n\n      if (this._json.networks[this.network_id] == null) {\n        return false;\n      }\n\n      return !!this.network.address;\n    },\n    detectNetwork: function detectNetwork() {\n      var constructor = this;\n      return new Promise(function (accept, reject) {\n        // Try to get the current blockLimit\n        constructor.web3.eth.getBlock(\"latest\").then(function (block) {\n          // Try to detect the network we have artifacts for.\n          if (constructor.network_id) {\n            // We have a network id and a configuration, let's go with it.\n            if (constructor.networks[constructor.network_id] != null) {\n              return accept({\n                id: constructor.network_id,\n                blockLimit: block.gasLimit\n              });\n            }\n          }\n\n          constructor.web3.eth.net.getId().then(function (network_id) {\n            // If we found the network via a number, let's use that.\n            if (constructor.hasNetwork(network_id)) {\n              constructor.setNetwork(network_id);\n              return accept({\n                id: constructor.network_id,\n                blockLimit: block.gasLimit\n              });\n            } // Otherwise, go through all the networks that are listed as\n            // blockchain uris and see if they match.\n\n\n            var uris = Object.keys(constructor._json.networks).filter(function (network) {\n              return network.indexOf(\"blockchain://\") === 0;\n            });\n            var matches = uris.map(function (uri) {\n              return BlockchainUtils.matches.bind(BlockchainUtils, uri, constructor.web3.currentProvider);\n            });\n            utils.parallel(matches, function (err, results) {\n              if (err) return reject(err);\n\n              for (var i = 0; i < results.length; i++) {\n                if (results[i]) {\n                  constructor.setNetwork(uris[i]);\n                  return accept({\n                    id: constructor.network_id,\n                    blockLimit: block.gasLimit\n                  });\n                }\n              } // We found nothing. Set the network id to whatever the provider states.\n\n\n              constructor.setNetwork(network_id);\n              return accept({\n                id: constructor.network_id,\n                blockLimit: block.gasLimit\n              });\n            });\n          }).catch(reject);\n        }).catch(reject);\n      });\n    },\n    setNetwork: function setNetwork(network_id) {\n      if (!network_id) return;\n      this.network_id = network_id + \"\";\n    },\n    setWallet: function setWallet(wallet) {\n      this.web3.eth.accounts.wallet = wallet;\n    },\n    // Overrides the deployed address to null.\n    // You must call this explicitly so you don't inadvertently do this otherwise.\n    resetAddress: function resetAddress() {\n      delete this.network.address;\n    },\n    link: function link(name, address) {\n      var constructor = this; // Case: Contract.link(instance)\n\n      if (typeof name === \"function\") {\n        var contract = name;\n\n        if (contract.isDeployed() === false) {\n          throw new Error(\"Cannot link contract without an address.\");\n        }\n\n        this.link(contract.contractName, contract.address); // Merge events so this contract knows about library's events\n\n        Object.keys(contract.events).forEach(function (topic) {\n          constructor.network.events[topic] = contract.events[topic];\n        });\n        return;\n      } // Case: Contract.link({<libraryName>: <address>, ... })\n\n\n      if (typeof name === \"object\") {\n        var obj = name;\n        Object.keys(obj).forEach(function (name) {\n          var a = obj[name];\n          constructor.link(name, a);\n        });\n        return;\n      } // Case: Contract.link(<libraryName>, <address>)\n\n\n      if (this._json.networks[this.network_id] == null) {\n        this._json.networks[this.network_id] = {\n          events: {},\n          links: {}\n        };\n      }\n\n      this.network.links[name] = address;\n    },\n    // Note, this function can be called with two input types:\n    // 1. Object with a bunch of data; this data will be merged with the json data of contract being cloned.\n    // 2. network id; this will clone the contract and set a specific network id upon cloning.\n    clone: function clone(json) {\n      var constructor = this;\n      json = json || {};\n\n      var temp = function TruffleContract() {\n        this.constructor = temp;\n        return Contract.apply(this, arguments);\n      };\n\n      temp.prototype = Object.create(constructor.prototype);\n      var network_id; // If we have a network id passed\n\n      if (typeof json !== \"object\") {\n        network_id = json;\n        json = constructor._json;\n      }\n\n      json = utils.merge({}, constructor._json || {}, json);\n      temp._constructorMethods = this._constructorMethods;\n      temp._properties = this._properties;\n      temp._property_values = {};\n      temp._json = json;\n      bootstrap(temp);\n      temp.web3 = new Web3();\n      temp.class_defaults = temp.prototype.defaults || {};\n\n      if (network_id) {\n        temp.setNetwork(network_id);\n      } // Copy over custom key/values to the contract class\n\n\n      Object.keys(json).forEach(function (key) {\n        if (key.indexOf(\"x-\") !== 0) return;\n        temp[key] = json[key];\n      });\n      return temp;\n    },\n    addProp: function addProp(key, fn) {\n      var constructor = this;\n\n      var getter = function getter() {\n        if (fn.get != null) {\n          return fn.get.call(constructor);\n        }\n\n        return constructor._property_values[key] || fn.call(constructor);\n      };\n\n      var setter = function setter(val) {\n        if (fn.set != null) {\n          fn.set.call(constructor, val);\n          return;\n        } // If there's not a setter, then the property is immutable.\n\n\n        throw new Error(key + \" property is immutable\");\n      };\n\n      var definition = {};\n      definition.enumerable = false;\n      definition.configurable = false;\n      definition.get = getter;\n      definition.set = setter;\n      Object.defineProperty(this, key, definition);\n    },\n    toJSON: function toJSON() {\n      return this._json;\n    },\n    decodeLogs: utils.decodeLogs\n  };\n};","map":null,"metadata":{},"sourceType":"script"}